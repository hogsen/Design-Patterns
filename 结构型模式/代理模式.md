# 代理模式

在代理模式中，通常涉及到一个接口，该接口定义了代理和真实对象（被代理对象）的共同行为，
代理对象在客户端和目标对象之间起到中介作用。
这样可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。

# 代码

加入你代码里已经有了对象 A,里面有你想要的方法,但是不能满足你的业务需求,你需要扩展它。
注意你不能去修改它, 你可以先创建一个接口，然后创建一个新类，这个新类通过实现接口去扩展原本的方法。
比如下面例子，你可以使用代理对象调用原生方法也可使用代理调用扩展方法。
调用原生方法使用了单例模式

```cs
// 通过代理调用扩展方法
MapProxy<BaiduMap>.Show();
MapProxy<GaodeMap>.Show();
// 通过代理调用原生方法
var map = MapProxy<BaiduMap>.Map;
map.Show();
// 假设你现在正在使用第三方库
class BaiduMap : IMap
{
  public void Show()
  {
    Console.WriteLine("您正在使用百度地图！");
  }
}
class GaodeMap : IMap
{
  public void Show()
  {
    Console.WriteLine("您正在使用高德地图！");
  }
}
// 你需要对第三方库进行扩展
interface IMap
{
  void Show();
}
// 创建第三方库的代理对象
class MapProxy<T> where T : IMap, new()
{
  // 代理对象中使用了单例模式，被代理的对象只能有一个实例
  private static readonly T single = new();
  // 私有构造函数，防止外部直接创建实例
  private static readonly string type = single.GetType().ToString();
  public static T Map => single;
  public static void Show()
  {
    Console.WriteLine($"{type}地图代理开始工作");
    single.Show();
  }
}


```
